    <div class="div-content">
      <span style="font-size: 1.5em; font-variant: small-caps; font-weight: bold;">Acerca de mí</span>

      <p style="text-indent: 1em;">
        Yo soy desarrollador de software independiente nacido y presentemente viviendo en la ilustre ciudad de Hamburgo, Alemania.  Cuento con 10 años de experiencia directa y conocimientos prácticos en las campos de programación de sistemas tanto de redes y administración de sistemas en Linux y Free/Net/OpenBSD.
        Afortunadamente dotado con habiéndome criado en al ambiente sumamente multicultural de Hamburgo y en una familia bilingüe, hablo a mis idiomas paternos, el Español (chileno/andaluz) e el Alemán (dialecto de Hamburgo) tanto como el Ingles (Ingles británico) con fluidez, a niveles de MCR C1 por criterio personal, hasta al Árabe clásico a nivel de MCR A2.
        Fuera de eso, me intereso mucho por el Árabe dentro del contexto del mundo hispánico tanto como la filosofía de el andaluz b. Rushd, al-Ghazali, Kant y Husserl y la psiquiatría &amp; psicología, particularmente Bleuler y Blankenburg. 
      </p>

      <span style="font-size: 1.5em; font-variant: small-caps; font-weight: bold;">Participación en proyectos open source</span><br />

      <span style="font-size: 1em; font-variant: small-caps; font-weight: bold;">midipix_build: infrastructura de build/cross-compilation para midipix, un ambiente de desarrollo/uso de usuario compatible con POSIX/Linux para Windows (Desde febrero de 2016)</span>
      <p style="text-indent: 1em;">
        Midipix<a href="http://www.midipix.org/">[1]</a> es un ambiente compatible con POSIX/Linux para Windows XP/Server 2003 y posterior, facilitando la cross-compilation y el uso de programas hechas para POSIX/Linux sin sufrir perdidas muy graves de rendimiento. A cambio de Cygwin<a href="https://www.cygwin.com/">[2]</a>, Midipix no requiere la interacción con el subsistema de ambiente Windows para la implementación de sus system calls, tanto como a cambio de Interix<a href="https://technet.microsoft.com/en-us/library/bb463204.aspx">[3]</a>, Midipix no consta de un subsistema ambiente por si mismo e así no introduce su propio servidor de subsistema y DLL(s) de cliente. No se requiere a la virtualización ni drivers de modo kernel para poder usar Midipix: en sus lugares una pequeña cantidad de “runtime components” facilitan la comunicación entre Musl, la libc elegida por este proyecto y la ejecutiva Windows NT (NTOSKRNL.EXE).
      </p>
      <p style="text-indent: 1em;">
        A comienzos del proyecto midipix_build<a href="https://github.com/lalbornoz/midipix_build">[4]</a> la [cross-]compilation de la toolchain, los runtime components y un numero abierto de software de terceros fue manejada por script de Bourne shell escritos ad hoc, un mecanismo que ultimadamente demostró padecer de escalabilidad y fiabilidad. Por lo tanto, surgió la necesidad para una infraestructura de build/cross-compilation suficientemente general e amplia. Por razones de la realidad fluida del proyecto Midipix mismo hasta el presente momento, he optado por un paradigma de desarrollo iterativo. Consideraciones acerca arquitectura fueron de meramente pequeña importancia.  Refactorización de código ha tomado lugar solamente dos veces y el presente concepto ha demostrado ser suficiente e adecuado para poder servir a los requisitos de Midipix. Las siguientas metas y requisitos surgieron en este proceso: 
      </p>
      <ol>
        <li>Portabilidad: midipix_build, semejante a build.sh de NetBSD menos make(1), ha tenido a y hasta cierto punto todavía tiene que facilitar la cross-compilation de un gran numero de programas tanto como en sistemas operativos que atienen a un grado alto de compatibilidad con el estándar POSIX. Por esta razón, fue escogido el Bourne shell como idioma de implementación, aprovechándose de solamente un pequeño numero de trazos non-POSIX, como por ejemplo variables locales a funciones. Esto permite que el build de Midipix en Linux, Cygwin, forma nativa (en Midipix mismo) y la mayoría de las variedades de BSD.</li>
        <li>Flexibilidad: la arquitectura de midipix_build tiene que ser suficientemente simple y mutable para así asistir fácilmente a la adición y/o la eliminación de trazos a una velocidad razonablemente alta como flavours, archivos de distribución signados, búsqueda automática de versiones mas recientes para software de terceros, etc. Además, el simple añadir de software de terceros con frecuencia impone la necesidad de introducir nuevos o volver a visitar las generalizaciones presentes, particularmente en relación a GNU autotools y sistemas de build basados en Cmake.</li>
        <li>Comodidad y fiabilidad: midipix_build normalmente se presenta como puerto de entrada para quien se interesa en el proyecto, por lo mas importante a través de los archivos de distribución que genera. Tanto desarrolladores como usuarios exigen la habilidad de la creación de uno o un grupo de software de terceros o los runtime components o el entero proceso.  Debido a esta razón, prácticamente todas las tareas comunes se realizan a través de una pequeña línea de comando invocando “build.sh”, sin demandar interacción manual.</li>
        <li>Simplicidad: por ultimo, baja complejidad y bajo tamaño de código, especialmente en relación a flexibilidad, siguen como prioridades: presentemente, el código con excepción de funciones/variables particulares de software/componentes cubre al rededor de 1200 SLOC, con el código particular a software/componentes añadiendo otros 1800 SLOC. Funciones reutilizables, realizadas como “pasos de build” (p. ej.: fetch, extract, build, install, ...) y pasos pre/post (p. ej.: setup_env, prereqs y sha256sums, tarballs, respectivamente) residen en sus propios módulos.</li>
      </ol>

      <span style="font-size: 1em; font-variant: small-caps; font-weight: bold;">Tcl TIP #458: concepción e implementación de apoyo epoll/kqueue en el notificador de Tcl en Linux/*BSD, respectivamente (<a href="https://github.com/flightaware/Tcl-bounties">FlightAware bounty programme</a>) (Noviembre hasta diciembre 2016)</span><br />
      <p style="text-indent: 1em;">
        Tcl (pronunciado /tí.quel/, originado del acrónimo en inglés "Tool Command Language" o "lenguaje de herramientas de comando", actualmente se escribe como "Tcl" en lugar de "TCL"), es un lenguaje de script creado por John Ousterhout, que ha sido concebido con una sintaxis sencilla para facilitarse su aprendizaje, sin detrimento de la funcionalidad y expresividad<a href="http://https://en.wikipedia.org/wiki/Tcl">[5]</a>.  Contribuciones a Tcl que alteran las interfaces publicas se ha de presentar a y se procesan a través del “Tcl Improvement Proposal (TIP)”<a href="http://wiki.tcl.tk/983">[6]</a>. A inicios de noviembre de 2016, un bounty programme “for improvements to Tcl and certain Tcl packages” fue publicado en GitHub<a href="https://github.com/flightaware/Tcl-bounties">[7]</a> por parte de FlightAware<a href="https://www.flightaware.com/">[8]</a>. Yo elegí a desarrollar el “[s]upport for epoll()/kqueue() to replace select() in socket handling,” tarea que termine a fines de diciembre 2016<a href="https://github.com/flightaware/Tcl-bounties/issues/14">[9]</a>. 
      </p>
      <p style="text-indent: 1em;">
        Tcl implementa una arquitectura event-based respecto a I/O y en particular utiliza callbacks para la notificación de I/O completion y procesamiento, ambas funciones que se implementan en el “notifier” no específico a plataforma. Originalmente, el único notifier en existencia utilizaba el system call select(2) para I/O multiplexing, que surgió como gran obstáculo para escabilidad. Las desventajas de select(2) son bien conocidos y profundizados en mi TIP<a href="https://www.tcl.tk/cgi-bin/tct/tip/458.html">[10]</a> y debido a estas razones no se examinan aquí, salvo el contingente impuesta por el uso de select(2) del numero de file descriptors de 1024. Los nuevos notifiers para Linux, utilizando epoll(7), y *BSD, utilizando kqueue(2), no sufren ningunos de esto defectos. 
      </p>
      <p style="text-indent: 1em;">
        Finalmente, el notifier original basado en select(2) implemento la notificación de eventos e IPC entre threads a través de un thread dedicado del notifier. Multithreading, sobre todo cuando sin justificación, por si solo introduce complejidad adicional y a menudo conducen a problemas de igual complejidad como race conditions, priority inversions, etc. Por lo tanto, los nuevos notificadores utilizan epoll(7)/kqueue(2) usando el contexto de thread del invocador sin introducir por si mismo nuevos threads. El problema de IPC entre threads fue, después de cierto debate sobre el tema en la lista de correo e IRC, solucionado con la introducción de una trigger pipe(2) en *BSD e eventfd(2) en Linux para cada thread. En consecuencia, añade un file descriptor por cada thread que trata con el notifer e un/dos file descriptors por IPC entre threads en *BSD/Linux, respectivamente. Como conduce a una perdida sustancial de complejidad gracias a la eliminación del notifier thread, esto se considera aceptable. Y lo mas importante, ningún thread, por parte del notifier, comparte implícitamente con otro thread file descriptors o estado. 
      </p>

      <span style="font-size: 1em; font-variant: small-caps;">Enlaces</span><br />
      [1]  <a href="http://www.midipix.org/">midipix</a><br />
      [2]  <a href="https://www.cygwin.com/">Cygwin</a><br />
      [3]  <a href="https://technet.microsoft.com/en-us/library/bb463204.aspx">Windows Services for UNIX Version 3.0</a><br />
      [4]  <a href="https://github.com/lalbornoz/midipix_build">GitHub - lalbornoz/midipix_build: Unified build Bourne shell script for midipix</a><br />
      [5]  <a href="http://https://en.wikipedia.org/wiki/Tcl">Tcl – Wikipedia</a><br />
      [6]  <a href="http://wiki.tcl.tk/983">Tcl Improvement Proposal</a><br />
      [7]  <a href="https://github.com/flightaware/Tcl-bounties">GitHub - flightaware/Tcl-bounties: Bounty program for improvements to Tcl and certain Tcl packages</a><br />
      [8]  <a href="https://www.flightaware.com/">FlightAware - Flug-Tracker / Flugstatus / Flugverfolgung</a><br />
      [9]  <a href="https://github.com/flightaware/Tcl-bounties/issues/14">[TIP] Intent to implement epoll()/kqueue() support for sockets on Linux/FreeBSD · Issue #14 · flightaware/Tcl-bounties · GitHub</a><br />
      [10] <a href="https://www.tcl.tk/cgi-bin/tct/tip/458.html">TIP #458: Add Support for epoll() and kqueue() in the Notifier</a><br />
    </div>

  <!--
    vim:ts=2 sw=2 expandtab fenc=utf-8 foldmethod=marker nowrap tw=0
    -->
